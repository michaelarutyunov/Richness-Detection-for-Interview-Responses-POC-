Here‚Äôs a clear, grounded recommendation for how to integrate `terminal_node_types` into your existing architecture ‚Äî written to fit the design idioms shown across your **component map**, **interview logic**, and **strategy/arbitration configuration**.

I‚Äôm keeping it direct, structured, and aligned with how your system already works.

---

# ‚úÖ **High-Level Recommendation**

You should integrate `terminal_node_types` as a **schema-level configuration** that flows through the system exactly the same way that:

* `node_types`
* `edge_types`
* extraction rules
* metadata

flow today.

This means:

### **1. Add terminal node types into the schema definition**

Already proposed:

```yaml
schema:
  terminal_node_types:
    - value  # for MEC, or:
    - desired_outcome
    - constraint  # for JTBD
```

### **2. Pass this into the interviewer state (graph_state + schema_state)**

The runtime engine should treat `terminal_node_types` as part of the active schema‚Äôs metadata.

### **3. Adjust ‚Äúvertical-only‚Äù logic**

Your arbitration rules currently center vertical pushing around ‚Äúvalue-proximity‚Äù ‚Äî that must become **terminal-proximity** in a schema-agnostic way.

### **4. Adjust ‚Äúclosure detection‚Äù**

Instead of checking ‚Äúhave we reached value?‚Äù, check whether the current branch has reached any **terminal node** defined by the schema.

### **5. Strategies remain unchanged; only the strategy selection logic needs to reference terminal nodes**

The strategies behave identically regardless of whether the schema ends in **values** (MEC) or **desired outcomes / constraints** (JTBD).

---

# üß© **Where terminal_node_types should be integrated**

### **Component map impact zones**

Your component map shows these layers:

1. **Schema Loader**
2. **Extraction Layer**
3. **Graph Manager**
4. **Strategy Selector**
5. **Arbitration Engine**
6. **Prompt Builder / LLM Orchestrator**
7. **Interview Loop**

The terminal node configuration touches only:

* **Schema Loader**
* **Graph Manager**
* **Strategy Selector**
* **Arbitration Engine**

Everything else is unaffected.

---

# üß† **Pseudo-Code Integration (Aligned to Your Architecture)**

Below is the exact pseudo-code blueprint for integrating `terminal_node_types`.
No changes to strategy definitions‚Äîonly scoring and branch logic.

---

# 1. **Schema Loader**

```python
def load_schema(schema_yaml):
    schema = parse_yaml(schema_yaml)

    schema_state = {
        "node_types": schema["node_types"],
        "edge_types": schema["edge_types"],
        "terminal_node_types": schema.get("terminal_node_types", [])
    }

    return schema_state
```

---

# 2. **Graph Manager: terminal detection**

Your GraphState should expose:

```python
class GraphState:
    def is_terminal(self, node, schema_state):
        return node.type in schema_state["terminal_node_types"]

    def nearest_terminal_distance(self, node, schema_state):
        # BFS upward to find nearest terminal-type node
        queue = [(node, 0)]
        visited = set()

        while queue:
            n, dist = queue.pop(0)
            if n.id in visited:
                continue
            visited.add(n.id)

            if self.is_terminal(n, schema_state):
                return dist

            for parent in self.get_parents(n):
                queue.append((parent, dist+1))

        return None  # no terminal found
```

---

# 3. **Strategy Selector: terminal-aware depth determination**

Change:

```python
if node.type == "value":
    score *= huge_boost
```

Into schema-agnostic:

```python
if graph_state.is_terminal(node, schema_state):
    score *= config.vertical_laddering["terminal_closure_boost"]
```

And similarly for proximity:

```python
distance = graph_state.nearest_terminal_distance(node, schema_state)

if distance is not None and distance <= config.vertical_laddering["near_terminal_depth"]:
    score *= config.vertical_laddering["terminal_proximity_boost"]
```

---

# 4. **Arbitration Engine: Update Vertical Laddering Scorer**

Replace the MEC hardcoded logic:

```python
value_proximity_boost
value_closure_boost
near_value_depth
```

With schema-agnostic equivalents:

```python
terminal_proximity_boost
terminal_closure_boost
near_terminal_depth
```

Implement scorers:

```python
def score_vertical_laddering(turn, graph_state, schema_state, config):
    node = turn.focus_node

    # Terminal closure
    if graph_state.is_terminal(node, schema_state):
        return config["terminal_closure_boost"]

    # Terminal proximity
    dist = graph_state.nearest_terminal_distance(node, schema_state)
    if dist is not None and dist <= config["near_terminal_depth"]:
        return config["terminal_proximity_boost"]

    return 1.0
```

---

# 5. **Reflection Mode Trigger**

Replace:

```python
min_value_nodes
```

with:

```python
min_terminal_nodes
```

And implement:

```python
def count_terminal_nodes(graph_state, schema_state):
    return sum(
        1 for node in graph_state.nodes 
        if node.type in schema_state["terminal_node_types"]
    )
```

---

# 6. **Prompt Builder / LLM Orchestration**

No changes needed.
It already generates content based on selected **strategy + tactic**.

---


---


